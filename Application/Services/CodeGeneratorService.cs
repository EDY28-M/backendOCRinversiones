using backendORCinverisones.Application.DTOs.Products;
using backendORCinverisones.Application.Interfaces.Repositories;
using backendORCinverisones.Application.Interfaces.Services;
using System.Text.RegularExpressions;

namespace backendORCinverisones.Application.Services;

public class CodeGeneratorService : ICodeGeneratorService
{
    private readonly IProductRepository _productRepository;
    
    public CodeGeneratorService(IProductRepository productRepository)
    {
        _productRepository = productRepository;
    }

    /// <inheritdoc />
    public async Task<AutoGeneratedCodesDto> GenerateBothCodesAsync()
    {
        var data = await _productRepository.GetCodigosForGenerationAsync();
        var codigos = data.Select(x => x.Codigo).ToList();
        var codigosComer = data.Select(x => x.CodigoComer).ToList();
        return new AutoGeneratedCodesDto
        {
            Codigo = ComputeNextCodigo(codigos),
            CodigoComer = ComputeNextCodigoComercial(codigosComer)
        };
    }
    
    public async Task<string> GenerateNextCodigoAsync()
    {
        try
        {
            var data = await _productRepository.GetCodigosForGenerationAsync();
            var existingCodes = data.Select(x => x.Codigo).Where(c => c.StartsWith("PR-")).ToList();
            return ComputeNextCodigo(existingCodes);
        }
        catch (Exception ex)
        {
            throw new ApplicationException("Error al generar código automático", ex);
        }
    }
    
    public async Task<string> GenerateNextCodigoComercialAsync()
    {
        try
        {
            var data = await _productRepository.GetCodigosForGenerationAsync();
            var existingCodes = data.Select(x => x.CodigoComer).ToList();
            return ComputeNextCodigoComercial(existingCodes);
        }
        catch (Exception ex)
        {
            throw new ApplicationException("Error al generar código comercial automático", ex);
        }
    }

    private static string ComputeNextCodigo(List<string> existingCodes)
    {
        if (existingCodes == null || !existingCodes.Any())
            return "PR-00001";

        var usedNumbers = new HashSet<int>();
        var regex = new Regex(@"^PR-(\d{5})$");
        foreach (var code in existingCodes)
        {
            var match = regex.Match(code);
            if (match.Success && int.TryParse(match.Groups[1].Value, out int number))
                usedNumbers.Add(number);
        }
        int nextNumber = 1;
        while (usedNumbers.Contains(nextNumber))
            nextNumber++;
        return $"PR-{nextNumber:D5}";
    }

    private static string ComputeNextCodigoComercial(List<string> existingCodes)
    {
        if (existingCodes == null || !existingCodes.Any())
            return "AA-0001";

        var usedCodes = new HashSet<string>(existingCodes.Where(c => !string.IsNullOrEmpty(c)));
        var regex = new Regex(@"^([A-Z]{2})-(\d{4})$");
        var validCodes = new List<(string letters, int number)>();
        foreach (var code in usedCodes)
        {
            var match = regex.Match(code);
            if (match.Success && int.TryParse(match.Groups[2].Value, out int number))
                validCodes.Add((match.Groups[1].Value, number));
        }
        if (!validCodes.Any())
            return "AA-0001";

        var codesByLetters = validCodes.GroupBy(c => c.letters).OrderBy(g => g.Key).ToList();
        foreach (var group in codesByLetters)
        {
            // ✅ OPTIMIZADO: Usa HashSet para búsqueda O(1) en lugar de List O(n)
            var usedNumbersSet = new HashSet<int>(group.Select(c => c.number));
            var maxNumber = usedNumbersSet.Max();

            // Buscar primer hueco disponible
            for (int i = 1; i <= maxNumber; i++)
            {
                if (!usedNumbersSet.Contains(i))
                    return $"{group.Key}-{i:D4}";
            }

            // Si no hay huecos, retornar el siguiente
            if (maxNumber < 9999)
                return $"{group.Key}-{(maxNumber + 1):D4}";
        }
        string lastLetters = codesByLetters.Last().Key;
        return $"{IncrementLetters(lastLetters)}-0001";
    }
    
    /// <summary>
    /// Verifica disponibilidad de código usando query optimizada (NO carga todas las entidades)
    /// </summary>
    public async Task<bool> IsCodigoAvailableAsync(string codigo)
    {
        if (string.IsNullOrWhiteSpace(codigo))
            return false;

        try
        {
            // ✅ OPTIMIZADO: Usa AnyAsync() directo en BD en lugar de cargar todos los productos
            var exists = await _productRepository.IsCodigoExistsAsync(codigo, null);
            return !exists;
        }
        catch (Exception ex)
        {
            throw new ApplicationException($"Error al verificar disponibilidad del código: {codigo}", ex);
        }
    }

    /// <summary>
    /// Verifica disponibilidad de código comercial usando query optimizada (NO carga todas las entidades)
    /// </summary>
    public async Task<bool> IsCodigoComercialAvailableAsync(string codigoComer)
    {
        if (string.IsNullOrWhiteSpace(codigoComer))
            return false;

        try
        {
            // ✅ OPTIMIZADO: Usa AnyAsync() directo en BD en lugar de cargar todos los productos
            var exists = await _productRepository.IsCodigoComercialExistsAsync(codigoComer, null);
            return !exists;
        }
        catch (Exception ex)
        {
            throw new ApplicationException($"Error al verificar disponibilidad del código comercial: {codigoComer}", ex);
        }
    }
    
    private static string IncrementLetters(string letters)
    {
        // Convertir letras a números (AA=0, AB=1, ..., ZZ=675)
        char[] chars = letters.ToCharArray();
        
        // Incrementar desde la derecha
        for (int i = chars.Length - 1; i >= 0; i--)
        {
            if (chars[i] == 'Z')
            {
                chars[i] = 'A';
                // Continuar con el siguiente dígito
            }
            else
            {
                chars[i] = (char)(chars[i] + 1);
                break;
            }
        }
        
        return new string(chars);
    }
}
